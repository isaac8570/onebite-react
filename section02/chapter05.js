// 원시 타입과 객체 타입
/*
원시타입 - Number, String, Boolean ... 값 자체로써 변수에 저장되고 복사된다
객체타입 - Object, Array, Function ... 참조값을 통해 변수에 저장되고 복사된다
*/

//원시타입 -> 불변값 = 원시데이터의 값이 바뀌는 것이 아님
let p1 = 1;
let p2 = p1;
// 메모리에 각각 값(1)이 할당된다
p2 = 2;
// 2를 새로운 메모리에 저장하고 그 메모리 주소를 가르킨다 -> 메모리 공간이 수정되는 것이 아님

// 객체타입 => 가변값 = 메모리 값이 수정된다
let o1 = { name: "김이삭" }; // o1는 참조값을 가르키고, 참조값에는 메모리가 담긴 주소가 적혀있음 (가르키는 역할)
let o2 = o1; // o2는 o1의 참조값을 함께 가르킴
o2.name = "홍길동"; // 이렇게 되면 원본 데이터(o1)도 함께 수정되어버림

/*
*객체 타입 주의사항
1. 의도치않게 값이 수정될 수 있음
그러므로 같은 객체 값을 사용하고 싶으면 이렇게 사용할것

let o1 = {name:"김이삭"};
let o2 = {...o1}; -> 객체를 새로 생성하고, 스프레드 연산자를 사용해 내부 프로퍼티 값을 복사해오는 것

o2.name ="홍길동"; -> o2만 변경됨

    *얕은복사 & 깊은복사
    얕은 복사 - 객체의 참조값을 복사함 -> 원본 객체가 수정될 수 있어 위험해!
    깊은 복사 - 새로운 객체를 생성하면서, 프로퍼티만 따로 복사 -> 원본 객체가 수정될 일이 없어 안전해!

2. 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다!
let o1 = {name:"김이삭"};
let o2 = o1;
let o3 = {...o1};

console.log(o1 === o2); -> true, 같은 참조값을 가르키므로
console.log(o1 === o3); -> false, 프로퍼티는 같지만, 참조값이 다르므로 
= 얕은 비교

만약 프로퍼티를 기준으로 객체를 비교하고 싶다면 ?
-> JSON.stringify() 자바 스크립트 내장함수 사용! -> 객체를 문자열로 변환하는 기능이 있어~

console.log(JSON.stringify(o1) === JSON.stringify(o3)) -> true
= 깊은 비교

3. 배열과 함수도 사실 객체이다
+

*/
